from Node import Node
import Queue


def traverse_tree(tree, flag):

    q=Queue.Queue()
    q.put(tree)
    diff=0
    max_node={}
    tree_dict={}
    while not q.empty():
        t = q.get()
        if flag=="Dictionary": tree_dict[t.val]=t

        for k in t.children:
            if flag=="Maximum":
                m = abs(t.val-k.val)
                if(m>=diff):
                    diff=m
                    max_node.setdefault(m,[]).append([k,t])

                # Used below to avoid putting leaf node in Queue
                if k.children is not None:
                    q.put(k)
            else:
                q.put(k)
    if flag=="Maximum": return max_node
    if flag=="Dictionary": return tree_dict


def create_b_tree(sub_tree):
    mid_element = len(sub_tree)/2
    new_root = Node(sub_tree.pop(mid_element))
    if len(sub_tree)==2:
        new_root.add_children(Node(sub_tree[0]))
        new_root.add_children(Node(sub_tree[1]))
    else:
        new_root.add_children(create_b_tree(sub_tree[0:len(sub_tree)/2]))
        new_root.add_children(create_b_tree(sub_tree[len(sub_tree)/2: len(sub_tree)]))
    return new_root


def create_initial_tree(initial_list_size):
    initial_list = range(1,(initial_list_size+1))
    root = Node(initial_list.pop((initial_list_size/2) -1))
    step=len(initial_list)/3
    chunks=[initial_list[x: (x+step)] for x in range(0, len(initial_list), step)]
    for i in chunks:
        root.add_children(create_b_tree(i))
    return root


def main():
    l = 22
    r = create_initial_tree(l)
    tree_dict=traverse_tree(r,"Dictionary")
    score=traverse_tree(r,"Maximum")
    print r

main()